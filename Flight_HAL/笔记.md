# Day02

## 03_ADC采集配置&测试.

1.数据缓冲区ADC_Value大小设置为1程序出现卡死的问题

**当缓冲区大小为1时：**

- DMA每完成一次转换，就会把数据写入这个唯一的存储单元。由于DMA循环模式会立即重新启动，这时HAL库内部可能会遇到状态同步或中断管理上的问题。
- 内部的**DMA传输完成回调可能被过于频繁地触发，导致状态机出现混乱或死锁**，最终使得`HAL_ADC_Start_DMA`函数无法正常返回，程序看似“卡死”在该函数调用处。

**当缓冲区大小为5时：**

- DMA需要连续完成5次转换后才会触发一次传输完成事件，内部状态的更新和回调处理相对更平稳，不会频繁进入中断处理，从而避免了状态机混乱。



2.老版本CubeMX代码生成问题

老版本MX_ADC1_Init();可能会在MX_DMA_Init();前，需要手动调整到MX_DMA_Init();后



3.电压值计算方式

3.3是参考电压，4095是ADC的分辨率（2的12次方），2是因为有分压电路，得到电压值再乘2

相当于将3.3分成4095份，得到一份的电压值，再乘以得到的份数ADC_Value[0]

一直取ADC_Value[0]，是因为电压值短时间是不会变化的，所以取哪都行



4.float bat_val = 0.0f的f含义

- 如果直接写 `0.0`，编译器会将其视为 **`double` 类型**（双精度浮点数，占 8 字节）。
- 如果加上 `f` 后缀（如 `0.0f`），则明确指定为 **`float` 类型**（单精度浮点数，占 4 字节）。
- **避免隐式类型转换**：
	如果赋值给 `float` 变量时不加 `f`，编译器会先将 `double` 类型的 `0.0` 隐式转换为 `float`，可能产生警告（如 `warning: narrowing conversion`）。
	加上 `f` 后缀后，直接使用 `float` 类型常量，避免转换。
- **节省内存和计算资源**：
	在嵌入式系统中，`float`（4 字节）比 `double`（8 字节）更节省内存，且单精度浮点运算通常更快。



5.中断问题

开启DMA后，会自动打开DMA中断，没完成一次完整的数据搬运（看如何设置），就会触发中断进而调用 **HAL_ADC_ConvCpltCallback**。

**DMA中断回调**

- 注意：对于ADC+DMA这种应用，推荐直接实现 **HAL_ADC_ConvCpltCallback**，而不是直接去重写DMA层的回调函数（如 HAL_DMA_ConvCpltCallback），因为HAL库内部已将DMA中断与ADC转换完成事件进行了关联。

不用再单独开启ADC的全局中断，只要开启了DMA，就能使用HAL_ADC_ConvCpltCallback进行中断回调



